% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/SurveyMap.R
\docType{data}
\name{SurveyMap}
\alias{SurveyMap}
\title{SurveyMap}
\format{An object of class \code{R6ClassGenerator} of length 25.}
\usage{
SurveyMap
}
\arguments{
\item{old_question}{The \link{SurveyQuestion} object to replace.}

\item{new_question}{The \link{SurveyQuestion} object to use instead.}

\item{fun}{The model fitting function to use. For example,
\code{fun=rstanarm::stan_glmer} or \code{fun=brms::brm}.}

\item{formula}{The model formula. Can be either a string or a formula
object.}

\item{...}{Arguments other than \code{formula} and \code{data} to pass to the model
fitting function.}

\item{fitted_model}{The name of the model that was fit. For example, \code{fit1}.}

\item{fun}{The function to use to generate the predicted probabilities.
This should only be specified if using a custom function, otherwise for
\pkg{rstanarm} and \pkg{brms} models \code{posterior_epred()} is
automatically used (with the result transposed) and for \pkg{lme4}
models the \code{\link[=sim_posterior_epred]{sim_posterior_epred()}} is used. If \code{fun} is a custom
function then the first argument should take in the fitted model object
and the second argument should take in the poststratification
(\code{newdata}) data frame. The function must return a matrix with rows
corresponding to the columns of the poststrat data and columns
corresponding to simulations.}

\item{...}{Arguments other than the fitted model and \code{newdata} data frame
to pass to \code{fun}.}
}
\value{
A matrix with rows corresponding to poststrat cells and columns
corresponding to posterior samples.
}
\description{
A \code{SurveyMap} object holds the mapping
between a set of items in a survey and a population dataset.
The label is the item label in each dataset and the values
is a list of all possible values.  The values for the survey
and population must be aligned, i.e., the lists must have the
same number of elements and the values at index i in each list
are equivalent.  If there is a meaningful ordering over the values,
they should be listed in that order, either descending or ascending.

Replace one survey question with another

Fit a model

Use fitted model to add predicted probabilities to post-stratification dataset.
}
\examples{
feline_prefs = SurveyObj$new(
  feline_survey[,c("age1","gender","pet_own","y")],
  questions = c("Please identify your age group","Please select your gender","Which pet do you own?", "Response"),
  responses = list(levels(feline_survey$age1),levels(feline_survey$gender),levels(feline_survey$pet_own),c("no","yes")),
  weights = feline_survey$wt,
  design = formula("~.")
)
popn_obj = SurveyObj$new(
  approx_popn[,c("age2","gender","pet_pref")],
  questions = c("Which age group are you?","Gender?","Which pet would you like to own?"),
  responses = list(levels(approx_popn$age2),levels(approx_popn$gender),levels(approx_popn$pet_pref)),
  weights = approx_popn$wt,
  design = formula("~.")
)
q1 <- question$new(
  name = "age",
  col_names = c("age1","age2"),
  values_map = list(
    "18-25" = "18-35", "26-35" = "18-35","36-45" = "36-55",
    "46-55" = "36-55", "56-65" = "56-65", "66-75" = "66+", "76-90" = "66+"
  )
)
q2 <- question$new(
  name = "pet",
  col_names = c("pet_own","pet_pref"),
  values_map = list("cat" = "cat", "kitten" = "cat","dog" = "dog","puppy" = "dog")
)
q3 <- question$new(
  name = "gender",
  col_names = c("gender","gender"),
  values_map = data.frame("male" = "m","female" = "f", "nonbinary" = "nb")
)

tmp_map <- SurveyMap$new(samp_obj = feline_prefs, popn_obj = popn_obj, q1)
print(tmp_map)
tmp_map$validate()
tmp_map$add(q3)
print(tmp_map)
tmp_map$delete(q3)
print(tmp_map)
tmp_map$add(q3)
tmp_map$delete("gender")
print(tmp_map)
tmp_map$add(q2)
print(tmp_map)
tmp_map$replace(q1,q3)
print(tmp_map)
tmp_map$add(q1)
print(tmp_map)
tmp_map$validate() # TODO: figure out why this errors
tmp_map$mapping()
tmp_map$tabulate("age") #Just use age in the poststrat matrix
tmp_map$tabulate() #Use all variables in the map


mod_fit_1 <- tmp_map$fit(
  fun = rstanarm::stan_glmer,
  formula = y ~ (1|age) + (1|gender),
  family = "binomial",
  refresh = 100,
  cores = 2
)

mod_fit_2 <- tmp_map$fit(
  fun = brms::brm,
  formula = y ~ (1|age) + (1|gender),
  family = "bernoulli",
  refresh = 100,
  cores = 2
)

class(mod_fit_1)

# predict in postrat matrix - returns a matrix
# with rows as poststrat rows, cols as posterior samples.
poststrat_fit <- tmp_map$predictify(mod_fit_1)

# get an estimate for a particular variable level or population
# arguments:
# - output of "predictify"
# - (optional) variable name
# body:
# - if no variable name then compute population estimate
# - if variable name specified compute weighted mean (N_j * theta)/sum(N_j)
# return type:
# - data.frame
#   - one column if popn estimate, otherwise one column per level of variable
#   - one row per posterior sample
# tmp_map$collapsify(poststrat_fit, variable = "age")
plot1 <- tmp_map$visualize()

}
\keyword{datasets}
