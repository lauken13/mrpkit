% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/SurveyFit.R
\name{SurveyFit}
\alias{SurveyFit}
\title{SurveyFit}
\description{
An \link[R6:R6Class]{R6} \code{SurveyFit} object stores a fitted model
object and provides methods for generating predicted probabilities for all
poststratification cells, generating population and group estimates, and
visualizing results.
}
\examples{

# Some fake survey data for demonstration
head(shape_survey)

# Create SurveyData object for the sample
box_prefs <- SurveyData$new(
  data = shape_survey,
  questions = list(
    age = "Please identify your age group",
    gender = "Please select your gender",
    vote_for = "Which party did you vote for in the 2018 election?",
    y = "If today is the election day, would you vote for the Box Party?"
  ),
  responses = list(
    age = levels(shape_survey$age),
    gender = levels(shape_survey$gender),
    # Here we use a data frame for the responses because the levels
    # in the data are abridged versions of the actual responses.
    # This can be useful when surveys have brief/non descriptive responses.
    vote_for = data.frame(
      data = levels(shape_survey$vote_for),
      asked = c("Box Party Faction A", "Box Party Faction B",
                "Circle Party Coalition", "Circle Party")
    ),
    y = c("no", "yes")
  ),
  weights = "wt",
  design = list(ids =~1)
)
box_prefs$print()
box_prefs$n_questions()


# Some fake population data for demonstration
head(approx_voters_popn)

# Create SurveyData object for the population
popn_obj <- SurveyData$new(
  data = approx_voters_popn,
  questions = list(
    age_group = "Which age group are you?",
    gender = "Gender?",
    vote_pref = "Which party do you prefer to vote for?"
  ),
  # order doesn't matter (gender before age here) because
  # the list has the names of the variables
  responses = list(
    gender = levels(approx_voters_popn$gender),
    age_group = levels(approx_voters_popn$age_group),
    vote_pref = levels(approx_voters_popn$vote_pref)
  ),
  weights = "wt"
)
popn_obj$print()


# Create the QuestionMap objects mapping each question between the
# survey and population dataset
q_age <- QuestionMap$new(
  name = "age",
  col_names = c("age","age_group"),
  values_map = list(
    "18-25" = "18-35", "26-35" = "18-35","36-45" = "36-55",
    "46-55" = "36-55", "56-65" = "56-65", "66-75" = "66+", "76-90" = "66+"
  )
)
print(q_age)

q_party_pref <- QuestionMap$new(
  name = "party_pref",
  col_names = c("vote_for","vote_pref"),
  values_map = list("Box Party" = "BP",  "BP" = "BP","Circle Party" = "CP", "CP" = "CP")
)
q_gender <- QuestionMap$new(
  name = "gender",
  col_names = c("gender", "gender"),
  values_map = list("male" = "m","female" = "f", "nonbinary" = "nb")
)


# Create SurveyMap object adding all questions at once
ex_map <- SurveyMap$new(
  sample = box_prefs,
  population = popn_obj,
  q_age,
  q_party_pref,
  q_gender
)
print(ex_map) # or ex_map$print()

# Or can add questions incrementally
ex_map <- SurveyMap$new(sample = box_prefs, population = popn_obj)
print(ex_map)

ex_map$add(q_age, q_party_pref)
print(ex_map)

ex_map$add(q_gender)
print(ex_map)


# Create the mapping between sample and population
ex_map$mapping()

# Create the poststratification data frame using all variables in the mapping
# (alternatively, can specify particular variables, e.g. tabulate("age"))
ex_map$tabulate()

# Take a peak at the poststrat data frame
head(ex_map$poststrat_data())

\dontrun{
# Fit regression model using rstanarm (returns a SurveyFit object)
fit_1 <- ex_map$fit(
  fun = rstanarm::stan_glmer,
  formula = y ~ (1|age) + (1|gender),
  family = "binomial",
  seed = 1111,
  chains = 1, # just to keep the example fast and small
  refresh = 0 # suppress printed sampling iteration updates
)

# To use lme4 or brms instead of rstanarm you would use:
# Example lme4 usage
# fit_2 <- ex_map$fit(
#   fun = lme4::glmer,
#   formula = y ~ (1|age) + (1|gender),
#   family = "binomial"
# )

# Example brms usage
# fit_3 <- ex_map$fit(
#   fun = brms::brm,
#   formula = y ~ (1|age) + (1|gender),
#   family = "bernoulli",
#   seed = 1111
# )


# Predicted probabilities
# returns matrix with rows for poststrat cells, cols for posterior draws
poststrat_estimates <- fit_1$population_predict()

# Compute and summarize estimates by age level and party preference
estimates_by_age <- fit_1$aggregate(poststrat_estimates, by = "age")
estimates_by_party <- fit_1$aggregate(poststrat_estimates, by = "party_pref")

fit_1$summary(estimates_by_age)
fit_1$summary(estimates_by_party)

# Plot estimates
fit_1$plot(estimates_by_party)

fit_1$plot(estimates_by_age)

fit_1$plot(estimates_by_age, additional_stats = "none")
fit_1$plot(estimates_by_age, additional_stats = "wtd")
fit_1$plot(estimates_by_age, additional_stats = "raw")
fit_1$plot(estimates_by_age, additional_stats = c("wtd","raw","mrp"))

# Compute and summarize the population estimate
estimates_popn <- fit_1$aggregate(poststrat_estimates)
fit_1$summary(estimates_popn)

# Plot population estimate
fit_1$plot(estimates_popn)
fit_1$plot(estimates_popn, additional_stats = "none")
fit_1$plot(estimates_popn, additional_stats = "wtd")
fit_1$plot(estimates_popn, additional_stats = "raw")
fit_1$plot(estimates_popn, additional_stats = c("wtd","raw","mrp"))
}

}
\section{Methods}{
\subsection{Public methods}{
\itemize{
\item \href{#method-SurveyFit-new}{\code{SurveyFit$new()}}
\item \href{#method-SurveyFit-fit}{\code{SurveyFit$fit()}}
\item \href{#method-SurveyFit-map}{\code{SurveyFit$map()}}
\item \href{#method-SurveyFit-formula}{\code{SurveyFit$formula()}}
\item \href{#method-SurveyFit-print}{\code{SurveyFit$print()}}
\item \href{#method-SurveyFit-population_predict}{\code{SurveyFit$population_predict()}}
\item \href{#method-SurveyFit-aggregate}{\code{SurveyFit$aggregate()}}
\item \href{#method-SurveyFit-summary}{\code{SurveyFit$summary()}}
\item \href{#method-SurveyFit-plot}{\code{SurveyFit$plot()}}
\item \href{#method-SurveyFit-clone}{\code{SurveyFit$clone()}}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-SurveyFit-new"></a>}}
\if{latex}{\out{\hypertarget{method-SurveyFit-new}{}}}
\subsection{Method \code{new()}}{
Create a new \code{SurveyFit} object. This method is called
internally by the \code{fit} method of the \code{\link{SurveyMap}} object and does
not need to be called directly by the user.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{SurveyFit$new(fit, map, formula)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{fit}}{A fitted model object.}

\item{\code{map}}{A \code{\link{SurveyMap}} object.}

\item{\code{formula}}{A formula object for the model that was fit.}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
A \code{SurveyFit} object.
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-SurveyFit-fit"></a>}}
\if{latex}{\out{\hypertarget{method-SurveyFit-fit}{}}}
\subsection{Method \code{fit()}}{
Access the fitted model object.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{SurveyFit$fit()}\if{html}{\out{</div>}}
}

\subsection{Returns}{
The fitted model object created by the modeling function called
by the \code{fit} method of the \code{\link{SurveyMap}} object. For example, if using
\code{rstanarm::stan_glmer()} then a \code{stanreg} object from \pkg{rstanarm} is
returned.
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-SurveyFit-map"></a>}}
\if{latex}{\out{\hypertarget{method-SurveyFit-map}{}}}
\subsection{Method \code{map()}}{
Access the \code{\link{SurveyMap}} object.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{SurveyFit$map()}\if{html}{\out{</div>}}
}

\subsection{Returns}{
The \code{\link{SurveyMap}} associated with the \code{SurveyFit} object.
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-SurveyFit-formula"></a>}}
\if{latex}{\out{\hypertarget{method-SurveyFit-formula}{}}}
\subsection{Method \code{formula()}}{
Access the model formula.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{SurveyFit$formula()}\if{html}{\out{</div>}}
}

\subsection{Returns}{
The model formula used when fitting the model.
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-SurveyFit-print"></a>}}
\if{latex}{\out{\hypertarget{method-SurveyFit-print}{}}}
\subsection{Method \code{print()}}{
Call the fitted model object's print method. The console
output from this method depends on the model fitting function used.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{SurveyFit$print(...)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{...}}{Optional arguments to pass the print method.}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
The \code{SurveyFit} object, invisibly.
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-SurveyFit-population_predict"></a>}}
\if{latex}{\out{\hypertarget{method-SurveyFit-population_predict}{}}}
\subsection{Method \code{population_predict()}}{
Use fitted model to add predicted probabilities to
post-stratification dataset.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{SurveyFit$population_predict(..., fun = NULL)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{...}}{Arguments other than the fitted model object and
poststratification data frame to pass to \code{fun}.}

\item{\code{fun}}{The function to use to generate the predicted probabilities.
This should only be specified if you used a model fitting function
not natively supported by \pkg{mrpkit}.
For models fit using \pkg{rstanarm}, \pkg{brms}, or \pkg{lme4}, \code{fun}
is handled automatically. If \code{fun} is specified then:
\itemize{
\item the first argument should be the fitted model object
\item the second argument should be the poststratification data frame
\item it can take an arbitrary number of other arguments
\item the returned object should match the specifications in the 'Returns'
section below in order to be compatible with subsequent methods
}}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
A matrix with rows corresponding to poststratification cells and
columns corresponding to posterior samples (or approximate ones
in the case of \pkg{lme4} models).
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-SurveyFit-aggregate"></a>}}
\if{latex}{\out{\hypertarget{method-SurveyFit-aggregate}{}}}
\subsection{Method \code{aggregate()}}{
Aggregate estimates to the population level or by level of a
grouping variable.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{SurveyFit$aggregate(poststrat_estimates, by = NULL)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{poststrat_estimates}}{The object returned by the \code{population_predict} method.}

\item{\code{by}}{Optionally a string specifying a grouping variable. If
specified the aggregation will happen by level of the named variable.
If not specified population-level estimates will be computed.}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
A data frame. If \code{by} is not specified then the data frame will
have number of rows equal to the number of posterior draws. If \code{by} is
specified the data frame will have number of rows equal to the number
of posterior draws times the number of levels of the \code{by} variable,
and there will be an extra column indicating which level of the \code{by}
variable each row corresponds to.
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-SurveyFit-summary"></a>}}
\if{latex}{\out{\hypertarget{method-SurveyFit-summary}{}}}
\subsection{Method \code{summary()}}{
Creates a set of summary statistics of the mrp estimate,
and corresponding weighted and raw data estimates
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{SurveyFit$summary(aggregated_estimates)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{aggregated_estimates}}{The data frame returned by the \code{aggregate} method.}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
A data frame that consists of a minimum three rows with the raw, MRP
and weighted estimates, plus an estimate of standard error. If the aggregated estimates
were specified with a \code{by} argument (indicating sub population or small area estimates),
then produces a dataframe with number of rows equal to three times the number of small areas.
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-SurveyFit-plot"></a>}}
\if{latex}{\out{\hypertarget{method-SurveyFit-plot}{}}}
\subsection{Method \code{plot()}}{
Plot takes the aggregated MRP estimates and produces a quick
visualization of total and sub-population estimates.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{SurveyFit$plot(aggregated_estimates, additional_stats = c("wtd", "raw"))}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{aggregated_estimates}}{The data frame returned by the \code{aggregate} method.}

\item{\code{additional_stats}}{A vector that specifies which of three additional
stats ("wtd", "raw", "mrp", "none") should be overlayed on the plot.
The default is to include the weighted estimate (wtd) and raw data mean
(raw), but an analogous bar for MRP (mrp) can be added using the
posterior mean and sd. The sd for the weighted estimate uses the survey
design and the \pkg{survey} package, whilst the raw estimate is a
direct mean and binomial sd of the binary responses. Uncertainty is
included on violin plots but not on density plots. Intervals are 95\%
CI.}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
A ggplot object that is either a violin plot (if aggregated
estimates is at a small area level) or density plot (if aggregated
estimates is at the population level).
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-SurveyFit-clone"></a>}}
\if{latex}{\out{\hypertarget{method-SurveyFit-clone}{}}}
\subsection{Method \code{clone()}}{
The objects of this class are cloneable with this method.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{SurveyFit$clone(deep = FALSE)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{deep}}{Whether to make a deep clone.}
}
\if{html}{\out{</div>}}
}
}
}
