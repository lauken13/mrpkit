% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/SurveyFit.R
\name{SurveyFit}
\alias{SurveyFit}
\title{SurveyFit}
\description{
An \link[R6:R6Class]{R6} \code{SurveyFit} object stores a fitted model
object and provides methods for generating predicted probabilities for all
poststrat cells, generating population and group estimates, and visualizing
results.
}
\examples{
library(dplyr)

head(shape_survey)
box_prefs <- SurveyData$new(
  data = shape_survey,
  questions = list(
    age = "Please identify your age group",
    gender = "Please select your gender",
    vote_for = "Which party did you vote for in the 2018 election?",
    y = "If today is the election day, would you vote for the Box Party?"
  ),
  responses = list(
    age = levels(shape_survey$age),
    gender = levels(shape_survey$gender),
    vote_for = levels(shape_survey$vote_for),
    y = c("no","yes")
  ),
  weights = shape_survey$wt,
  design = list(ids =~1)
)
box_prefs$print()
box_prefs$n_questions()

head(approx_voters_popn)
popn_obj <- SurveyData$new(
  data = approx_voters_popn,
  questions = list(
    age_group = "Which age group are you?",
    gender = "Gender?",
    vote_pref = "Which party do you prefer to vote for?"
  ),
  # order doesn't matter (gender before age2 here) because
  # the list has the names of the variables
  responses = list(
    gender = levels(approx_voters_popn$gender),
    age_group = levels(approx_voters_popn$age_group),
    vote_pref = levels(approx_voters_popn$vote_pref)
  ),
  weights = approx_voters_popn$wt
)
popn_obj$print()

q_age <- QuestionMap$new(
  name = "age",
  col_names = c("age","age_group"),
  values_map = list(
    "18-25" = "18-35", "26-35" = "18-35","36-45" = "36-55",
    "46-55" = "36-55", "56-65" = "56-65", "66-75" = "66+", "76-90" = "66+"
  )
)
print(q1)

q_party_pref <- QuestionMap$new(
  name = "party_pref",
  col_names = c("vote_for","vote_pref"),
  values_map = list("Box Party" = "BP",  "BP" = "BP","Circle Party" = "CP", "CP" = "CP")
)
q_gender <- QuestionMap$new(
  name = "gender",
  col_names = c("gender", "gender"),
  values_map = list("male" = "m","female" = "f", "nonbinary" = "nb")
)

# Create SurveyMap object adding all questions at once
ex_map <- SurveyMap$new(
  sample = box_prefs,
  population = popn_obj,
  q_age,
  q_party_pref,
  q_gender
)
print(ex_map) # or ex_map$print()

# Or can add questions incrementally
ex_map <- SurveyMap$new(sample = box_prefs, population = popn_obj)
print(ex_map)

ex_map$add(q_age, q_party_pref)
print(ex_map)

ex_map$add(q_gender)
print(ex_map)

# Create the mapping between sample and population
ex_map$mapping()

# Create the poststratification data frame using all variables in the mapping
# (alternatively, can specify particular variables, e.g. tabulate("age"))
ex_map$tabulate()

# Example rstanarm usage
# Returns a SurveyFit object
fit_1 <- ex_map$fit(
  fun = rstanarm::stan_glmer,
  formula = y ~ (1|age) + (1|gender),
  family = "binomial",
  seed = 1111
)

# Example lme4 usage
# fit_2 <- ex_map$fit(
#   fun = lme4::glmer,
#   formula = y ~ (1|age) + (1|gender),
#   family = "binomial"
# )
#
# Example brms usage
# fit_3 <- ex_map$fit(
#   fun = brms::brm,
#   formula = y ~ (1|age) + (1|gender),
#   family = "bernoulli",
#   seed = 1111
# )


# predicted probabilities
# returns matrix with rows for poststrat cells, cols for posterior draws
poststrat_estimates <- fit_1$population_predict()

# estimates by age level
estimates_by_age <- fit_1$aggregate(poststrat_estimates, by = "age")
head(estimates_by_age)
estimates_by_age \%>\%
  group_by(age) \%>\%
  summarize(mean = mean(value), sd = sd(value))

# plot estimates by age
fit_1$plot(estimates_by_age)

# population estimate
estimates_popn <- fit_1$aggregate(poststrat_estimates)
mean(estimates_popn$value)

# plot population estimate
fit_1$plot(estimates_popn)

}
\section{Methods}{
\subsection{Public methods}{
\itemize{
\item \href{#method-new}{\code{SurveyFit$new()}}
\item \href{#method-fit}{\code{SurveyFit$fit()}}
\item \href{#method-map}{\code{SurveyFit$map()}}
\item \href{#method-print}{\code{SurveyFit$print()}}
\item \href{#method-population_predict}{\code{SurveyFit$population_predict()}}
\item \href{#method-aggregate}{\code{SurveyFit$aggregate()}}
\item \href{#method-plot}{\code{SurveyFit$plot()}}
\item \href{#method-clone}{\code{SurveyFit$clone()}}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-new"></a>}}
\if{latex}{\out{\hypertarget{method-new}{}}}
\subsection{Method \code{new()}}{
Create a new \code{SurveyFit} object. This method is called
internally by the \verb{$fit()} method of the \code{\link{SurveyMap}} object and does
not need to be called directly by the user.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{SurveyFit$new(fit, map)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{fit}}{A fitted model object.}

\item{\code{map}}{A \code{\link{SurveyMap}} object.}
}
\if{html}{\out{</div>}}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-fit"></a>}}
\if{latex}{\out{\hypertarget{method-fit}{}}}
\subsection{Method \code{fit()}}{
Access the fitted model object
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{SurveyFit$fit()}\if{html}{\out{</div>}}
}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-map"></a>}}
\if{latex}{\out{\hypertarget{method-map}{}}}
\subsection{Method \code{map()}}{
Access the SurveyMap object
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{SurveyFit$map()}\if{html}{\out{</div>}}
}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-print"></a>}}
\if{latex}{\out{\hypertarget{method-print}{}}}
\subsection{Method \code{print()}}{
Call the fitted model object's print method
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{SurveyFit$print(...)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{...}}{Optional arguments to pass the print method.}
}
\if{html}{\out{</div>}}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-population_predict"></a>}}
\if{latex}{\out{\hypertarget{method-population_predict}{}}}
\subsection{Method \code{population_predict()}}{
Use fitted model to add predicted probabilities to post-stratification dataset.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{SurveyFit$population_predict(..., fun = NULL)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{...}}{Arguments other than the fitted model object and
poststratification data frame to pass to \code{fun}.}

\item{\code{fun}}{The function to use to generate the predicted probabilities.
This should only be specified if you used a model fitting function
not natively supported by \pkg{mrpkit}.
For models fit using \pkg{rstanarm}, \pkg{brms}, or \pkg{lme4}, \code{fun}
is handled automatically. If \code{fun} is specified then:
\itemize{
\item the first argument should be the fitted model object
\item the second argument should be the poststratification data frame
\item it can take an arbitrary number of other arguments
\item the returned object should match the specifications in the 'Returns'
section below in order to be compatible with subsequent methods
}}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
A matrix with rows corresponding to poststratification cells and
columns corresponding to posterior samples (or approximate ones
in the case of \pkg{lme4} models).
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-aggregate"></a>}}
\if{latex}{\out{\hypertarget{method-aggregate}{}}}
\subsection{Method \code{aggregate()}}{
Aggregate estimates to the population level or by level of a grouping variable
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{SurveyFit$aggregate(poststrat_estimates, by = NULL)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{poststrat_estimates}}{The object returned by \code{population_predict}.}

\item{\code{by}}{Optionally a string specifying a grouping variable. If
specified the aggregation will happen by level of the named variable.
If not specified population-level estimates will be computed.}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
A data frame. If \code{by} is not specified then the data frame will
have number of rows equal to the number of posterior draws. If \code{by} is
specified the data frame will have number of rows equal to the number
of posterior draws times the number of levels of the \code{by} variable,
and there will be an extra column indicating which level of the \code{by}
variable each row corresponds to.
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-plot"></a>}}
\if{latex}{\out{\hypertarget{method-plot}{}}}
\subsection{Method \code{plot()}}{
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{SurveyFit$plot(aggregated_estimates, weights = TRUE)}\if{html}{\out{</div>}}
}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-clone"></a>}}
\if{latex}{\out{\hypertarget{method-clone}{}}}
\subsection{Method \code{clone()}}{
The objects of this class are cloneable with this method.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{SurveyFit$clone(deep = FALSE)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{deep}}{Whether to make a deep clone.}
}
\if{html}{\out{</div>}}
}
}
}
