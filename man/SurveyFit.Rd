% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/SurveyFit.R
\name{SurveyFit}
\alias{SurveyFit}
\title{SurveyFit}
\description{
An \link[R6:R6Class]{R6} \code{SurveyFit} object stores a fitted model
object and provides methods for generating predicted probabilities for all
poststrat cells, generating population and group estimates, and visualizing
results.
}
\examples{
library(dplyr)

head(feline_survey)
feline_prefs <- SurveyData$new(
  data = feline_survey,
  questions = list(
    age1 = "Please identify your age group",
    gender = "Please select your gender",
    pet_own = "Which pet do you own?",
    y = "Response"
  ),
  responses = list(
    age1 = levels(feline_survey$age1),
    gender = levels(feline_survey$gender),
    pet_own = levels(feline_survey$pet_own),
    y = c("no","yes")
  ),
  weights = feline_survey$wt
)
feline_prefs$print()

head(approx_popn)
popn_obj <- SurveyData$new(
  data = approx_popn,
  questions = list(
    age2 = "Which age group are you?",
    gender = "Gender?",
    pet_pref = "Which pet would you like to own?"
  ),
  # order doesn't matter (gender before age2 here) because
  # the list has the names of the variables
  responses = list(
    gender = levels(approx_popn$gender),
    age2 = levels(approx_popn$age2),
    pet_pref = levels(approx_popn$pet_pref)
  ),
  weights = approx_popn$wt
)
popn_obj$print()

q1 <- SurveyQuestion$new(
  name = "age",
  col_names = c("age1","age2"),
  values_map = list(
    "18-25" = "18-35", "26-35" = "18-35","36-45" = "36-55",
    "46-55" = "36-55", "56-65" = "56-65", "66-75" = "66+", "76-90" = "66+"
  )
)
q2 <- SurveyQuestion$new(
  name = "pet",
  col_names = c("pet_own","pet_pref"),
  values_map = list("cat" = "cat", "kitten" = "cat","dog" = "dog","puppy" = "dog")
)
q3 <- SurveyQuestion$new(
  name = "gender",
  col_names = c("gender","gender"),
  values_map = data.frame("male" = "m","female" = "f", "nonbinary" = "nb")
)

# Create SurveyMap object
# can add all questions at once or incrementally
ex_map <- SurveyMap$new(sample = feline_prefs, population = popn_obj, q1)
print(ex_map)
ex_map$validate()
ex_map$add(q3)
print(ex_map)
ex_map$delete(q3)
print(ex_map)
ex_map$add(q3)
ex_map$delete("gender")
print(ex_map)
ex_map$add(q2)
print(ex_map)
ex_map$replace(q1,q3)
print(ex_map)
ex_map$add(q1)
print(ex_map)
ex_map$validate()
ex_map$mapping()
ex_map$tabulate("age") # Just use age in the poststrat matrix
ex_map$tabulate() # Use all variables in the map


#' Example rstanarm usage
#' Returns a SurveyFit object
fit_1 <- ex_map$fit(
  fun = rstanarm::stan_glmer,
  formula = y ~ (1|age) + (1|gender),
  family = "binomial",
  refresh = 100,
  cores = 2
)

\dontrun{
# Example brms usage
# Returns a SurveyFit object
# (not run because requires compilation)
fit_2 <- ex_map$fit(
  fun = brms::brm,
  formula = y ~ (1|age) + (1|gender),
  family = "bernoulli",
  refresh = 100,
  cores = 2
)
}

# predicted probabilities
# returns matrix with rows for poststrat cells, cols for posterior draws
poststrat_estimates <- fit_1$population_predict()

# estimates by age level
estimates_by_age <- fit_1$aggregate(poststrat_estimates, by = "age")
head(estimates_by_age)
estimates_by_age \%>\%
  group_by(age) \%>\%
  summarize(mean = mean(value), sd = sd(value))

# plot estimates by age
fit_1$plot(estimates_by_age)

# population estimate
estimates_popn <- fit_1$aggregate(poststrat_estimates)
mean(estimates_popn$value)

# plot population estimate
fit_1$plot(estimates_popn)

}
\section{Methods}{
\subsection{Public methods}{
\itemize{
\item \href{#method-new}{\code{SurveyFit$new()}}
\item \href{#method-fit}{\code{SurveyFit$fit()}}
\item \href{#method-map}{\code{SurveyFit$map()}}
\item \href{#method-print}{\code{SurveyFit$print()}}
\item \href{#method-population_predict}{\code{SurveyFit$population_predict()}}
\item \href{#method-aggregate}{\code{SurveyFit$aggregate()}}
\item \href{#method-plot}{\code{SurveyFit$plot()}}
\item \href{#method-clone}{\code{SurveyFit$clone()}}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-new"></a>}}
\if{latex}{\out{\hypertarget{method-new}{}}}
\subsection{Method \code{new()}}{
Create a new \code{SurveyFit} object. This method is called
internally by the \verb{$fit()} method of the \code{\link{SurveyMap}} object and does
not need to be called directly by the user.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{SurveyFit$new(fit, map)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{fit}}{A fitted model object.}

\item{\code{map}}{A \code{\link{SurveyMap}} object.}
}
\if{html}{\out{</div>}}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-fit"></a>}}
\if{latex}{\out{\hypertarget{method-fit}{}}}
\subsection{Method \code{fit()}}{
Access the fitted model object
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{SurveyFit$fit()}\if{html}{\out{</div>}}
}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-map"></a>}}
\if{latex}{\out{\hypertarget{method-map}{}}}
\subsection{Method \code{map()}}{
Access the SurveyMap object
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{SurveyFit$map()}\if{html}{\out{</div>}}
}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-print"></a>}}
\if{latex}{\out{\hypertarget{method-print}{}}}
\subsection{Method \code{print()}}{
Call the fitted model object's print method
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{SurveyFit$print(...)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{...}}{Optional arguments to pass the print method.}
}
\if{html}{\out{</div>}}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-population_predict"></a>}}
\if{latex}{\out{\hypertarget{method-population_predict}{}}}
\subsection{Method \code{population_predict()}}{
Use fitted model to add predicted probabilities to post-stratification dataset.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{SurveyFit$population_predict(..., fun = NULL)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{...}}{Arguments other than the fitted model object and
poststratification data frame to pass to \code{fun}.}

\item{\code{fun}}{The function to use to generate the predicted probabilities.
This should only be specified if you used a model fitting function
not natively supported by \pkg{mrpkit}.
For models fit using \pkg{rstanarm}, \pkg{brms}, or \pkg{lme4}, \code{fun}
is handled automatically. If \code{fun} is specified then:
\itemize{
\item the first argument should be the fitted model object
\item the second argument should be the poststratification data frame
\item it can take an arbitrary number of other arguments
\item the returned object should match the specifications in the 'Returns'
section below in order to be compatible with subsequent methods
}}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
A matrix with rows corresponding to poststratification cells and
columns corresponding to posterior samples (or approximate ones
in the case of \pkg{lme4} models).
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-aggregate"></a>}}
\if{latex}{\out{\hypertarget{method-aggregate}{}}}
\subsection{Method \code{aggregate()}}{
Aggregate estimates to the population level or by level of a grouping variable
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{SurveyFit$aggregate(poststrat_estimates, by = NULL)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{poststrat_estimates}}{The object returned by \code{population_predict}.}

\item{\code{by}}{Optionally a string specifying a grouping variable. If
specified the aggregation will happen by level of the named variable.
If not specified population-level estimates will be computed.}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
A data frame. If \code{by} is not specified then the data frame will
have number of rows equal to the number of posterior draws. If \code{by} is
specified the data frame will have number of rows equal to the number
of posterior draws times the number of levels of the \code{by} variable,
and there will be an extra column indicating which level of the \code{by}
variable each row corresponds to.
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-plot"></a>}}
\if{latex}{\out{\hypertarget{method-plot}{}}}
\subsection{Method \code{plot()}}{
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{SurveyFit$plot(aggregated_estimates, weights = TRUE)}\if{html}{\out{</div>}}
}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-clone"></a>}}
\if{latex}{\out{\hypertarget{method-clone}{}}}
\subsection{Method \code{clone()}}{
The objects of this class are cloneable with this method.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{SurveyFit$clone(deep = FALSE)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{deep}}{Whether to make a deep clone.}
}
\if{html}{\out{</div>}}
}
}
}
