---
title: "Getting Started with MRP-Kit"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Getting Started with MRP-Kit}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---


```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

```{r setup}
library(mrpkit)
```

This vignette presents the typical workflow of MRP-kit usage, an R package for implementing a "grammar" for multilevel regression with post-stratification. 


# Introduction

The aim of MRP-Kit is to create a set of grammar to perform the Multilevel Regression with Poststratification (MRP). By using this package, we will get the workflow of MRP from creating the metadata of the survey and post-stratification objects, mapping it, fitting the model, getting the prediction and aggregating the value, and visualizing it. Hence, it will create a more reproducible and accountable environment for conducting an MRP analysis. 

Unlike most of R packages, the MRP-kit implements the usage of [Object Oriented Programming (R6 objects)](https://adv-r.hadley.nz/r6.html) (Chang, 2019). Thus, instead of calling a function to perform a task, we call a method that is embedded to an object using `object$method`. This package create four objects, which are `SurveyData`, `SurveyQuestion`, `SurveyMap`, and `SurveyFit`. There are several methods in each of these objects that will be explained later on in this vignette.   


# Prerequisites

Some of the methods in MRP-kit use external packages to be able to function i.e. `forcats` (Wickham, 2020) `SurveyMapping$mapping`, `dplyr` (Wickham, François, Henry & Müller, 2020) in  `SurveyMapping$tabulate`, and `ggplot2` (Wickham, 2016) in `SurveyFit$visify`. In fitting the MPR model, you might also need these packages:

- rstanarm (Goodrich, Gabry, Ali, & Brilleman, 2020), at least 2.21.0 version
- brms (Bürkner, 2017)
- lme4 (Bates, Maechler, Bolker, Walker, 2015) and merTools (Knowles & Frederick, 2020)


# Workflow

The workflow of using MRP-Kit to perform an MRP analysis is listed as follows:

1. Prepare the data.
2. Create the `SurveyData` objects.
3. Match the value between survey and post-stratification object for each questions with `SurveyQuestion$new`.
4. Map the question between survey and population data with `SurveyMap`.
5. Fit the model using `SurveyFit`.
6. Get the estimate value based on post-stratification dataset.
7. Aggregate the prediction value to a higher level for example for state/province basis. 
8. Visualize the estimated data. 

The detailed example of this workflow would be explained as follows:

## Prepare the data

In this vignette we used a simulated data sets as the example of survey data and approximate population/post-stratification data. These data sets display the preference of voters to Neverland Labor Party (NLP), a political party in a fake country, Neverland, along with demographic variables, age and gender. The population is designed using `declare_population` function from `DeclareDesign` (Blair, Cooper, Coppock & Humphreys, 2019) to set the features in the population.

We can see every variables in the survey data as follows:

```{r}
head(nlp_survey)
```

Additionally, the approximate population could be seen as follows:

```{r}
head(approx_voters_popn)
```
 

## Create the SurveyData objects 

A `SurveyData` objects is an object represents the data, both of the survey and the post-stratification data, along with its metadata. The survey metadata consists of the survey's variables, question in the questionnaire, level of response, the survey's weight, and its design formula (random sample, one stage cluster sample, and stratified sample).

This object has three methods, which are `SurveyData$new`, `SurveyData$print`, and `SurveyData$clone`. The `SurveyData$new` is used to transform a regular data frame to a `SurveyData` object, whereas `SurveyData$print` and `SurveyData$clone` are used to print and clone the created `SurveyData` object. 

In this example, we will show the steps to create the `SurveyData` object using `SurveyData$new` method. This method takes five arguments, which are the metadata of the survey and post-stratification data, listed as follows: 

1. List of column/variable labels/names.
2. `questions`: The question asked in the questionnaire for each of those columns.
3. `responses`: Allowed response for each question.
4. `weights`: The survey weights. 
5. `design`: The design formula of the survey, include:
   - `~.` for a random sample
   - `~ (1|cluster)` for one stage cluster sample
   - `~ stratum:` for a stratified sample
   
After the `SurveyData` initialized, we can print it using `print` method as is shown in the code below:

**Create the `SurveyData` object for the survey data set**
   
```{r}
# create the SurveyData object for survey data
nlp_pref <- SurveyData$new(
  nlp_survey[,c("age","gender","vote_for","y")],
  questions = c("Please identify your age group",
                "Please select your gender",
                "Which party did you vote for in the 2018 election?",
                "If today is election day, will you vote for the NLP?"),
  responses = list(levels(nlp_survey$age),
                   levels(nlp_survey$gender),
                   levels(nlp_survey$vote_for),
                   c("no","yes")),
  weights = nlp_survey$wt,
  design = formula("~."))

# print it
nlp_pref$print()
```

**Create the `SurveyData` object for the post-stratification data set**


```{r}

# create SurveyData object for post-stratification data
popn_obj <- SurveyData$new(
  approx_voters_popn[,c("age_group","gender","vote_pref")],
  questions = c("Which age group are you?",
                "Which gender are you identified?",
                "Which party do you prefer to vote?"),
  responses = list(levels(approx_voters_popn$age_group),
                   levels(approx_voters_popn$gender),
                   levels(approx_voters_popn$vote_pref)),
  weights = approx_voters_popn$wt,
  design = formula("~."))

# print it
popn_obj$print() 
```


## Match the value between survey and post-stratification object using `SurveyQuestion$new`

From the metadata above, we can see that the survey and post-stratification data have a different 
label of columns, so do the level/categorization of age, gender, and party preference. For example in `nlp_pref`, the column label for age is `age`, whereas in `popn_obj`, the column label for this variable is `age_group`. This variable also has different level, `nlp_pref` has 7 levels of age, whereas `popn_obj` has only 4 levels of age. 

These column labels and levels should be aligned to be able to perform MRP. With `SurveyQuestion$new` method, we are able to define the same name of column label and mapping its value into the same of categorization. This method takes three arguments, which are:

1. `name` : the same name for the variable. This would be used in the modeling stage. 
2. `col_names`: the column labels in the survey and post-stratification object where the variable refers to. 
3. `values_map`: mapping the values between the survey and post-stratification object. 

Here is the example of how this method works:

```{r}
# create SurveyQuestion$object for question related to age
q1 <- SurveyQuestion$new(
  name = "age",
  col_names = c("age","age_group"),
  values_map = list(
    "18-25" = "18-35", "26-35" = "18-35","36-45" = "36-55",
    "46-55" = "36-55", "56-65" = "56-65", "66-75" = "66+", "76-90" = "66+"))

# create SurveyQuestion$object for question related to party preference
q2 <- SurveyQuestion$new(
 name = "party_pref",
 col_names = c("vote_for","vote_pref"),
 values_map = list("Neverland Labor Party" = "NLP", "NLP" = "NLP","Neverland Democrats" = "The Democrats","The Democrats" = "The Democrats"))

# create SurveyQuestion$object for question related to gender
q3 <- SurveyQuestion$new(
  name = "gender",
  col_names = c("gender","gender"),
  values_map = data.frame("male" = "m","female" = "f", "nonbinary" = "nb"))

```


## Using the handy SurveyMap


The `SurveyMap` has seven methods as listed as follows:


```{r}
tmp_map <- SurveyMap$new(samp_obj = nlp_pref, popn_obj = popn_obj, q1)
print(tmp_map)
tmp_map$validate()
tmp_map$add(q3)
print(tmp_map)
tmp_map$delete(q3)
print(tmp_map)
tmp_map$add(q3)
tmp_map$delete("gender")
print(tmp_map)
tmp_map$add(q2)
print(tmp_map)
tmp_map$replace(q1,q3)
print(tmp_map)
tmp_map$add(q1)
print(tmp_map)
tmp_map$validate()
tmp_map$mapping()
tmp_map$tabulate("age") # Just use age in the poststrat matrix
tmp_map$tabulate() # Use all variables in the map

print(tmp_map)
```



## Fit the Model <-<- incorporated the new method 


```{r, eval = FALSE}
# the example of using stan_glmer
fit1 <- tmp_map$fit(
  fun = rstanarm::stan_glmer,
  formula = y ~ (1|age) + (1|gender),
  family = "binomial",
  refresh = 100,
  cores = 2)

fit2 <- tmp_map$fit(
  fun = lme4::glmer,
  formula = y ~ (1|age) + (1|gender),
  family = "binomial")
```

```{r eval = FALSE}
mod_fit_1 <- SurveyFit$new(fit1, tmp_map)
mod_fit_2 <- SurveyFit$new(fit2, tmp_map)
```

```{r}
print(mod_fit_1)
```
```{r}
print(mod_fit_2)
```


## Get the Prediction 

```{r eval=FALSE}
# predict in postrat matrix - returns a matrix
# with rows as poststrat rows, cols as posterior samples.


poststrat_fit1 <- mod_fit_1$predictify()


poststrat_fit2 <- mod_fit_2$predictify()


# get an estimate for a particular variable level or population
# arguments:
# - output of "predictify"
# - (optional) variable name
##### in order to make it the same pattern as other, predict? instead of predictify?

```


## Make the Aggregate

```{r eval = FALSE}
# body:
# - if no variable name then compute population estimate
# - if variable name specified compute weighted mean (N_j * theta)/sum(N_j)
# return type:
# - data.frame
# - one column if popn estimate, otherwise one column per level of variable
# - one row per posterior sample

# other alternative name : collapse?

sae_preds<- mod_fit_1$collapsify(poststrat_fit1)

popn_preds2 <- tmp_map$collapsify(poststrat_fit2)

```


## Visualise It

```{r eval =FALSE}
```


```{r eval=FALSE}
plot1 <- tmp_map$visify(popn_preds)
plot1
```

