---
title: "Getting Started with MRP-Kit"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Getting Started with MRP-Kit}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---


```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

```{r setup}
library(mrpkit)
```

This vignette presents the typical workflow of MRP-kit usage, an R package for implementing a "grammar" for multilevel regression with post-stratification. 


# Introduction

The aim of MRP-Kit is to create a set of grammar to perform the Multilevel Regression with Poststratification (MRP). By using this package, we will get the workflow of MRP from creating the metadata of the survey and post-stratification objects, mapping it, fitting the model, getting the prediction and aggregating the value, and visualizing it. Hence, it will create a more reproducible and accountable environment for conducting an MRP analysis. 

Unlike most of R packages, the MRP-kit implements the usage of [Object Oriented Programming (R6 objects)](https://adv-r.hadley.nz/r6.html) (Chang, 2019). Thus, instead of calling a function to perform a task, we call a method that is embedded to an object using `object$method`. This package create four objects, which are `SurveyData`, `SurveyQuestion`, `SurveyMap`, and `SurveyFit`. There are several methods in each of these objects that will be explained later on in this vignette.   


# Prerequisites

Some of the methods in MRP-kit use external packages to be able to function i.e. `forcats` (Wickham, 2020) `SurveyMapping$mapping`, `dplyr` (Wickham, François, Henry & Müller, 2020) in  `SurveyMapping$tabulate`, and `ggplot2` (Wickham, 2016) in `SurveyFit$visify`. In fitting the MPR model, you might also need these packages:

- rstanarm (Goodrich, Gabry, Ali, & Brilleman, 2020), at least 2.21.0 version
- brms (Bürkner, 2017)
- lme4 (Bates, Maechler, Bolker, Walker, 2015) and merTools (Knowles & Frederick, 2020)


# Workflow

The workflow of using MRP-Kit to perform an MRP analysis is listed as follows:

1. Prepare the data.
2. Create the `SurveyData` objects.
3. Match the value in the survey and population questions with `SurveyQuestion` object.
4. Map the question between survey and population data with `SurveyMap` object.
5. Fit the model using `SurveyFit` object.
6. Get the estimate value based on post-stratification dataset.
7. Aggregate the prediction value to a higher level for example for state/province basis. 
8. Visualize the estimated data. 

The detailed example of this workflow would be explained as follows:

## Prepare the data

In this vignette we used a simulated data sets as the example of survey data and approximate population/post-stratification data. These data sets display the preference of voters to Neverland Labor Party (NLP), a political party in a fake country, Neverland, along with demographic variables, age and gender. The population is designed using `declare_population` function from `DeclareDesign` (Blair, Cooper, Coppock & Humphreys, 2019) to set the features in the population.

We can see every variables in the survey data as follows:

```{r}
head(nlp_survey)
```

Additionally, the approximate population could be seen as follows:

```{r}
head(approx_voters_popn)
```
From the tables above we can see that the survey and post-stratification data have a different value of age and gender. This is one of the main uses of MRP-kit which to align the value between the survey and post-stratification data. 



## Create the SurveyData Objects 

A `SurveyData` objects is an object represents the data, both of the survey and population data, along with its metadata. The survey metadata consists of the survey's variables, question in the questionnaire, level of response, the survey's weight, and its design formula (random sample, one stage cluster sample, and stratified sample).

This object has three methods, which are `SurveyData$new`, `SurveyData$print`, and `SurveyData$clone`. The `SurveyData$new` is used to transform a survey data frame to a `SurveyData` object, whereas `SurveyData$print` and `SurveyData$clone` are used to print and clone the created `SurveyData` object. 

Here is the example code of how to create `SurveyData` from the survey and approximate population data frame. 

```{r}
nlp_pref <- SurveyData$new(
  nlp_survey[,c("age","gender","vote_for","y")],
  questions = c("Please identify your age group",
                "Please select your gender",
                "Which party did you vote for in the 2018 election?",
                "If today is election day, which party will you vote for?"),
  responses = list(levels(nlp_survey$age),
                   levels(nlp_survey$gender),
                   levels(nlp_survey$vote_for),
                   c("no","yes")),
  weights = nlp_survey$wt,
  design = formula("~."))

nlp_pref$print()
```


```{r}
popn_obj <- SurveyData$new(
  approx_voters_popn[,c("age_group","gender","vote_pref")],
  questions = c("Which age group are you?",
                "Which gender are you identified?",
                "Which party do you prefer to vote?"),
  responses = list(levels(approx_voters_popn$age_group),
                   levels(approx_voters_popn$gender),
                   levels(approx_voters_popn$vote_pref)),
  weights = approx_voters_popn$wt,
  design = formula("~."))




#popn_obj$print() 
```


## Match the Value in Survey's Questions with SurveyQuestion

```{r}
q1 <- SurveyQuestion$new(
  name = "age",
  col_names = c("age","age_group"),
  values_map = list(
    "18-25" = "18-35", "26-35" = "18-35","36-45" = "36-55",
    "46-55" = "36-55", "56-65" = "56-65", "66-75" = "66+", "76-90" = "66+"))

q2 <- SurveyQuestion$new(
 name = "party_pref",
 col_names = c("vote_for","vote_pref"),
 values_map = list("Neverland Labor Party" = "NLP", "NLP" = "NLP","Neverland Democrats" = "The Democrats","The Democrats" = "The Democrats"))

q3 <- SurveyQuestion$new(
  name = "gender",
  col_names = c("gender","gender"),
  values_map = data.frame("male" = "m","female" = "f", "nonbinary" = "nb"))

```


## Using the Handy SurveyMap

```{r}
tmp_map <- SurveyMap$new(samp_obj = nlp_pref, popn_obj = popn_obj, q1)
print(tmp_map)
tmp_map$validate()
tmp_map$add(q3)
print(tmp_map)
tmp_map$delete(q3)
print(tmp_map)
tmp_map$add(q3)
tmp_map$delete("gender")
print(tmp_map)
tmp_map$add(q2)
print(tmp_map)
tmp_map$replace(q1,q3)
print(tmp_map)
tmp_map$add(q1)
print(tmp_map)
tmp_map$validate()
tmp_map$mapping()
tmp_map$tabulate("age") # Just use age in the poststrat matrix
tmp_map$tabulate() # Use all variables in the map
```



## Fit the Model <-<- incorporated the new method 


```{r, eval = FALSE}
# the example of using stan_glmer
tmp_fit_1 <- tmp_map$fit(
  fun = rstanarm::stan_glmer,
  formula = y ~ (1|age) + (1|gender),
  family = "binomial",
  refresh = 100,
  cores = 2)

mod_fit_2 <- tmp_map$fit(
  fun = lme4::glmer,
  formula = y ~ (1|age) + (1|gender),
  family = "binomial")
```

```{r eval = FALSE}
mod_fit_1 <- SurveyFit$new(tmp_fit_1,
  tmp_map)
```



## Get the Prediction 

```{r eval=FALSE}
# predict in postrat matrix - returns a matrix
# with rows as poststrat rows, cols as posterior samples.


poststrat_fit1 <- mod_fit_1$predictify

poststrat_fit2 <- tmp_map$predictify(mod_fit_2, sim_posterior_epred)


# get an estimate for a particular variable level or population
# arguments:
# - output of "predictify"
# - (optional) variable name
##### in order to make it the same pattern as other, predict? instead of predictify?

```


## Make the Aggregate

```{r eval = FALSE}
# body:
# - if no variable name then compute population estimate
# - if variable name specified compute weighted mean (N_j * theta)/sum(N_j)
# return type:
# - data.frame
# - one column if popn estimate, otherwise one column per level of variable
# - one row per posterior sample

# other alternative name : collapse?

sae_preds<- poststrat_fit1$collapsify(variable_aggr = "age")
popn_preds2 <- tmp_map$collapsify(poststrat_fit2)

```


## Visualise It

```{r eval =FALSE}
```


```{r eval=FALSE}
plot1 <- tmp_map$visify(popn_preds)
plot1
```

