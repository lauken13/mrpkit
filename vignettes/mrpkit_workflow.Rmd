---
title: "Getting Started with MRP-Kit"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Getting Started with MRP-Kit}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---


```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

```{r setup}
library(mrpkit)
```

This vignette presents the typical workflow of MRP-kit usage, an R package for implementing a "grammar" for multilevel regression with post-stratification. 


# Introduction

The aim of MRP-Kit is to create a set of grammar to perform the Multilevel Regression with Poststratification (MRP). By using this package, we will get the workflow of MRP from creating the metadata of the survey and post-stratification objects, mapping it, fitting the model, getting the prediction and aggregating the value, and visualizing it. Hence, it will create a more reproducible and accountable environment for conducting an MRP analysis. 

Unlike most of R packages, the MRP-kit implements the usage of [Object Oriented Programming (R6 objects)](https://adv-r.hadley.nz/r6.html) (Chang, 2019). Thus, instead of calling a function to perform a task, we call a method that is embedded to an object using `object$method`. This package create four objects, which are `SurveyData`, `SurveyQuestion`, `SurveyMap`, and `SurveyFit`. There are several methods in each of these objects that will be explained later on in this vignette.   


# Prerequisites

Some of the methods in MRP-kit use external packages to be able to function i.e. `forcats` (Wickham, 2020) `SurveyMapping$mapping`, `dplyr` (Wickham, François, Henry & Müller, 2020) in  `SurveyMapping$tabulate`, and `ggplot2` (Wickham, 2016) in `SurveyFit$visify`. In fitting the MRP model, you might also need these packages:

- rstanarm (Goodrich, Gabry, Ali, & Brilleman, 2020), at least 2.21.0 version
- brms (Bürkner, 2017)
- lme4 (Bates, Maechler, Bolker, Walker, 2015) and merTools (Knowles & Frederick, 2020)


# Workflow

The workflow of using MRP-Kit to perform an MRP analysis is listed as follows:

1. Prepare the data.
2. Create the `SurveyData` objects.
3. Match the value between survey and post-stratification data for each question.
4. Map the question between survey and post-stratification data.
5. Fit the model.
6. Get the estimate value based on post-stratification data.
7. Aggregate the prediction value to a higher level for example for state/province basis. 
8. Visualize the estimated data. 

The detailed example of this workflow would be explained as follows:

## Prepare the data

In this vignette we used a simulated data sets as the example of survey data and approximate population/post-stratification data. These data sets display the preference of voters to Neverland Labor Party (NLP), a political party in a fake country, Neverland, along with demographic variables, age and gender. The population is designed using `declare_population` function from `DeclareDesign` (Blair, Cooper, Coppock & Humphreys, 2019) to set the features in the population.

We can see every variables in the survey data as follows:

```{r}
head(nlp_survey)
```

Additionally, the approximate population could be seen as follows:

```{r}
head(approx_voters_popn)
```
 

## Create the SurveyData objects 

A `SurveyData` objects is an object represents the data, both of the survey and the post-stratification data, along with its metadata. The survey metadata consists of the survey's variables, question in the questionnaire, level of response, the survey's weight, and its design formula (random sample, one stage cluster sample, and stratified sample).

This object has three methods, which are `SurveyData$new`, `SurveyData$print`, and `SurveyData$clone`. The `SurveyData$new` is used to transform a regular data frame to a `SurveyData` object, whereas `SurveyData$print` and `SurveyData$clone` are used to print and clone the created `SurveyData` object. 

In this example, we will show the steps to create the `SurveyData` object using `SurveyData$new` method. This method takes five arguments, which are the metadata of the survey and post-stratification data, listed as follows: 

1. List of column/variable labels/names.
2. `questions`: The question asked in the questionnaire for each of those columns.
3. `responses`: Allowed response for each question.
4. `weights`: The survey weights. 
5. `design`: The design formula of the survey, include:
   - `~.` for a random sample
   - `~ (1|cluster)` for one stage cluster sample
   - `~ stratum:` for a stratified sample
   
After the `SurveyData` initialized, we can print it using `print` method as is shown in the code below:

**Create the `SurveyData` object for the survey data set**
   
```{r}
# create the SurveyData object for survey data
nlp_pref <- SurveyData$new(
  nlp_survey[,c("age","gender","vote_for","y")],
  questions = c("Please identify your age group",
                "Please select your gender",
                "Which party did you vote for in the 2018 election?",
                "If today is election day, will you vote for the NLP?"),
  responses = list(levels(nlp_survey$age),
                   levels(nlp_survey$gender),
                   levels(nlp_survey$vote_for),
                   c("no","yes")),
  weights = nlp_survey$wt,
  design = formula("~."))

# print it
nlp_pref$print()
```

**Create the `SurveyData` object for the post-stratification data set**


```{r}

# create SurveyData object for post-stratification data
popn_obj <- SurveyData$new(
  approx_voters_popn[,c("age_group","gender","vote_pref")],
  questions = c("Which age group are you?",
                "Which gender are you identified?",
                "Which party do you prefer to vote?"),
  responses = list(levels(approx_voters_popn$age_group),
                   levels(approx_voters_popn$gender),
                   levels(approx_voters_popn$vote_pref)),
  weights = approx_voters_popn$wt,
  design = formula("~."))

# print it
popn_obj$print() 
```


## Match the value between survey and post-stratification object using `SurveyQuestion$new`

From the metadata above, we can see that the survey and post-stratification data have a different 
label of columns, so do the level/categorization of age, gender, and party preference. For example in `nlp_pref`, the column label for age is `age`, whereas in `popn_obj`, the column label for this variable is `age_group`. This variable also has different level, `nlp_pref` has 7 levels of age, whereas `popn_obj` has only 4 levels of age. 

These column labels and levels should be aligned to be able to perform MRP. With `SurveyQuestion$new` method, we are able to define the same name of column label and mapping its value into the same of categorization. Further, if there is a meaningful ordering over the values, they should be sorted over that order, either descending or ascending. 

This method takes three arguments, which are:

1. `name` : the same name for the variable. This would be used in the modeling stage. 
2. `col_names`: the column labels in the survey and post-stratification object where the variable refers to. 
3. `values_map`: mapping the values between the survey and post-stratification object. 

Here is the example of how this method works:

```{r}
# create SurveyQuestion$object for question related to age
q1 <- SurveyQuestion$new(
  name = "age",
  col_names = c("age","age_group"),
  values_map = list(
    "18-25" = "18-35", "26-35" = "18-35","36-45" = "36-55",
    "46-55" = "36-55", "56-65" = "56-65", "66-75" = "66+", "76-90" = "66+"))

# create SurveyQuestion$object for question related to party preference
q2 <- SurveyQuestion$new(
 name = "party_pref",
 col_names = c("vote_for","vote_pref"),
 values_map = list("Neverland Labor Party" = "NLP", "NLP" = "NLP","Neverland Democrats" = "The Democrats","The Democrats" = "The Democrats"))

# create SurveyQuestion$object for question related to gender
q3 <- SurveyQuestion$new(
  name = "gender",
  col_names = c("gender","gender"),
  values_map = data.frame("male" = "m","female" = "f", "nonbinary" = "nb"))

```


## Using the handy SurveyMap

`SurveyMap` object holds the mapping between a set of items in a survey and a post-stratification data. It takes the `SurveyData` objects, in this case are `nlp_pref` and `popn_obj` together with labels and values that have been matched and provided in the `SurveyQuestion` object. The map object would specify the correspondences in the variables that will be used when fitting the model. 

The `SurveyMap` has eight methods as listed as follows:

1. `new`
   
    This method is used to initialize a new `SurveyMap` object. This takes `SurveyData` and `SurveyQuestion` objects as its arguments. It should be noted that we should include all of the  `SurveyQuestion` objects that correspondence to variables that will be used in the MRP model. 
   
2. `validate`

    This method is used for `SurveyMap` object validation. It will throw an error if there is a level mismatch in the map. Additionally, it will give a warning when one or more variables are available in post-stratification data but they are not mapped, thus it would not be used in the model. 
    
    Below is the example of `new` and `validate` methods usage:

```{r}
# create a new SurveyMap object
tmp_map <- SurveyMap$new(samp_obj = nlp_pref, popn_obj = popn_obj, q1)

# validate the map
tmp_map$validate()

```

3. `add`

    To get rid of the warning above, we could use this method to add other `SurveyQuestion` object to the map. Here is the example of the code:
    
```{r}
# add party_pref and gender to the map.
tmp_map$add(q2, q3)
print(tmp_map)
```

4. `delete`

    Now we already have all of the variables in the post-stratification data mapped. Sometimes, you do not want including all of the variables in the model, for example, in this example, we want to exclude `gender` from the model. 

```{r}
# we can also use the label instead of the object name
tmp_map$delete("gender")
print(tmp_map)
```

5. `replace`

    Suppose that you changed your mind and want to use `gender` in the model instead of `party_pref`. The `replace` method can perform this task with the `old question` as the first argument and the `new question` as the second argument. The example of this method could be seen as follows:
    
```{r}
tmp_map$replace(q2, q3)
print(tmp_map)
```
    
6. `mapping`

    Once you are happy with your map object, you can prepare the mapped data for the model fitting with `mapping` method. 

```{r}
tmp_map$mapping()
```


7. `tabulate`

    The next step is to prepare the post-stratification table using `tabulate` method. If you want to only use certain variable in the post-stratification matrix, then you should put that variable as the argument. For instance, here, we only use `age` in the post-stratification matrix.

```{r}
tmp_map$tabulate("age")
```

If you want to include all of the variable in the post-stratification matrix, then the method should not take any argument.
    
    
```{r}
tmp_map$tabulate()
```


8. `fit`

    Finally, we are able to fit the model using `fit` method. Currently this package support `rstanarm::stan_glmer`, `lme4::glmer`, `brms::brm` as the functions that are built-into the package. However, you could also specify your own function. In this case, you should give a `data` argument that accepts a data frame (like standard R modeling functions). In this example, we fit two models using `fun=rstanarm::stan_glmer` and `fun=lme4::glmer` with `age` and `gender` as the predictors. 

```{r eval = FALSE}
# the example of using stan_glmer
fit1 <- tmp_map$fit(
  fun = rstanarm::stan_glmer,
  formula = y ~ (1|age) + (1|gender),
  family = "binomial",
  refresh = 100,
  cores = 2)

fit2 <- tmp_map$fit(
  fun = lme4::glmer,
  formula = y ~ (1|age) + (1|gender),
  family = "binomial")

```


## Playing with the fitted model with `SurveyFit`

In this stage, we already have the fitted model i.e. `fit1` and `fit2`. We can store these fitted model objects into an object called `SurveyFit`. Further, using this object, we can generate the predicted probabilities for all post-stratification cell, aggregate the estimate to a higher level, for example to state or province estimate, and visualize the aggregated estimates. 

### Create `SurveyFit` object

To create the `SurveyFit` object, we could use `SurveyFit$new` method. This method takes two arguments, which are the fitted model object and the mapping object. Since we have two fitted model, we will create two `SurveyFit` objects. 

```{r eval = FALSE}
# SurveyFit object for fit1
mod_fit_1 <- SurveyFit$new(fit1, tmp_map)

# SurveyFit object for fit2
mod_fit_2 <- SurveyFit$new(fit2, tmp_map)
```


### Get the prediction value of each post-stratification cell

After creating the `SurveyFit` object, we are able to generate the predicted probability of each post-stratification cell using a method called `predictify`. It return a matrix with rows correspond to the columns of post-stratification data and columns correspond to the posterior samples. 

Furthermore, if the model fitting done with one of the built-in function (`rstanarm::stan_glmer`, `lme4::glmer`, `brms::brm`), then this method does not take any arguments. However, if you used a customized function in the model fitting, then this method takes two argument. The first is the fitted model object, and the second is the post-stratification data frame. 

In this example, we will show how to use this method for `mod_fit_1` object. Additionally, if you only want to only predict the probability of certain variable, then you could specify that variable in the method. 

```{r eval=FALSE}

# predict all variable
poststrat_fit1 <- mod_fit_1$predictify()

# predict only age 
poststrat_fit1_age <- mod_fit_1$predictify("age")


```


### Aggregate the prediction to a higher level of estimate

The next step is to generate the population estimate or group estimate using `collapsify` method. This method takes two arguments, namely the post-stratification fit data and the variable that is aggregated, in this example we want to aggregate `age` variable. If the variable is not specified, then this method would generate a population estimate. 

```{r eval = FALSE}

# aggregate the predicted value by age
sae_preds <- mod_fit_1$collapsify(poststrat_fit1, variable_aggr = "age")

# generate the population estimate
popn_preds <- mod_fit_1$collapsify(poststrat_fit1)

```


### Visualise it

Once we have the collapsed value of the estimates, we are able to visualize it using `visify` method. This method takes in the aggregated data frame as the argument. It generate a violin plot of the estimate aggregated variable or the population prediction. In the example below, we show the example of the estimate of `age` variable. 

```{r eval=FALSE}
plot1 <- tmp_map$visify(sae_preds)
plot1
```



